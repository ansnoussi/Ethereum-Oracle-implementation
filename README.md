# Ethereum Oracle implementation

## Reason

The Ethereum blockchain is designed to be deterministic which is necessary so that nodes can come to a consensus.
That's why smart contracts on the Ethereum blockchain lack Internet Connectivity simply because it is NOT deterministic (exp : if we query and API at a certain point in time, we cannot guarantee that later querying the same API will get the same result: data could change, or the API itself could be down.)

## Solution: Oracle

Oracles are services that insert data on the blockchain to be used by smart contract.
The Oracle implemented here has the following features:

- Can query JSON APIs and retrieve a single value from the API response
- Has a predefined set of stakeholders (node.js service that queries the APIs)
- Has a minimum number of equal responses to come to a consensus

## Architecture

![Architecture Description](./overview.drawio.svg)

## On-chain oracle

> **Note:** Oracle definition and comments are is in /on-chain-contracts/Oracle.sol

To start the on-chain oracle :
**1**. `make init-on-chain` will initialise the on-chain oracle and install all dependencies
**2**. `make start-emulator` will start the blockchain emulator
**2**. `make deploy` to compile the Oracle smart contract and deploy it.

In `Oracle.sol` you will notice that the adresses for the Oracle nodes is hardcoded in the contract

```
// Hardcoded oracles address
r.quorum[address(0xFB4208A18E30240aB9b63A859AfEC4a78f105234)] = 1;
r.quorum[address(0xCC9b2DD34aB336781D082F2Cd47236a3e40D9d67)] = 1;
r.quorum[address(0x5f227f4FfFd7288f20eD157A203dB07e6534288d)] = 1;
```

Because when we start the blockchain emulator by running `make start-emulator` we are actually running this command :

```
ganache-cli -a 3 -d -m "dial antenna tail zebra chef violin entry grass volcano tail sunny scrub"
```

- `-a` or `--accounts`: Specify the number of accounts to generate at startup.
- `-d` or `--deterministic`: Generate deterministic addresses based on a pre-defined mnemonic.
- `-m` or `--mnemonic`: Use a specific HD wallet mnemonic to generate initial addresses.

This way the adresses generated by the Ethereum emulator are consistant across tries and later we could import that mnemonic in metamask so we can sign the transactions from the off-chain oracles.
